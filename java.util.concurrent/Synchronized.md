# Synchronized


Synchronized在JVM里的实现原理：JVM基于进入和退出Monitor对象来实现方法同步和代码块同步。

- monitorenter指令是在编译后插入到同步代码块的开始位置

- monitorexit指令是插入到方法结束处和异常处


JVM保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有之后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权。  


根据虚拟机的规范，在执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1。相应的，在执行monitorexit指令时会把锁的计数器减1，当计数器为0时，锁就会被释放。

Synchronized同步块对于同一条线程来说是可重入的，不会出现把自己锁死的情况。同步块在已经入的线程执行完之前，会阻塞后面其他线程的进入，Java的线程是映射到操作系统的原生线程之上的。如果要阻塞或唤醒一个线程，都需要操作系统来帮忙，这就需要从用户态转到内核态，因此需要花费大量的CPU时间。


在Java SE 1.6中，锁一共有4种状态，级别从低到高分别是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但是不能降级。

## Java 对象头

Java对象头里的Mark Word里默认存储对象的HashCode、分代年龄和锁标记位。32位JVM的Mark Word默认存储结构如下：

 锁状态 | 25bit | 4bit | 1bit 是否为偏向锁 | 2bit锁标志位 
 --- | ---- | --- |  --- | ---
   无锁状态  |  对象的HashCode | 对象分代年龄 | 0 | 01
   

对象头信息是对自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。

存储内容 | 标志位 | 状态
--- | --- | ---
对象HashCode、对象分代年龄 | 01 | 未锁定
偏向线程ID、偏向时间戳、对象分代年龄 | 01 | 可偏向
指向锁记录的指针 | 00 | 轻量级锁定
指向重量级锁的指针 | 10 | 膨胀（重量级锁定）
空，不需要记录信息 | 11 | GC标记

## 轻量级锁

在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位01），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储对象目前的Mark Word的拷贝（称为 Displaced Mark Word）。

![](http://owj98yrme.bkt.clouddn.com/4986428-f5e67b86e6fd906d.png)


然后虚拟机使用CAS操作尝试将对象头的Mark Word更新指向Lock Record的指针。

- 如果更新操作成功，那么该线程拥有对象的锁，并且对象头的Mark Word状态转变为轻量级锁定。


![](http://owj98yrme.bkt.clouddn.com/4986428-b0a7916dd19ca424.png)


- 如果更新操作失败，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧

	- 如果是说明当前线程已经拥有了这个对象的锁，那么就可以直接进入同步块继续执行；
	
	- 如果不是，说明这个锁对象已经被其他线程抢占。

	
### 重量级锁


接着上面继续说，线程更新轻量级锁状态失败。那么即此时有两条以上的线程争用同一个锁，那轻量级锁不再有效，要膨胀为重量级锁，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待的线程也要进入阻塞状态。


### 释放锁

轻量级锁的释放过程也是通过CAS操作来进行的，如果对象的Mark Word仍然指向着线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来，如果替换成功，整个同步过程就结束了。如果替换失败，说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。

### 优缺点

轻量级锁提升程序同步性能的依据是：对于大部分的锁，在整个同步过程周期内都是不存在竞争的。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但是如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁的开销比传统的重量级锁更大。


## 偏向锁

偏向锁是JDK 1.6种引入的一项锁优化，它的目的是消除数据在无竞争的情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。


偏向锁的意思即这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。

假设当前虚拟机启用了偏向锁（启用参数 -XX:+UseBiasedLocking），那么，当锁对象第一次被线程获取的时候，虚拟机会将对象头状态更新为偏向模式。同时使用CAS操作把获取到这个锁的线程ID、偏向时间戳和锁对象的分代年龄记录在对象Mark Word中。如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块，虚拟机可以不再进行任何同步操作（比如Locking、Unlocking和Mark Word的Update等）。

当有另一个线程尝试获取这个锁时，偏向模式宣告结束。根据锁对象目前是否处于被锁定的状态，撤销偏向后恢复到未锁定或者轻量级锁状态。即偏向锁是一次性的。。。

![](http://owj98yrme.bkt.clouddn.com/4986428-f80d528c2554f262.png)



当然，如果程序中大多数的锁总线处于并发被获取状态，那么偏向模式就是多余的。


## 自旋锁和自适应自旋


自旋锁对于单个CPU是无效的。


互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给操作系统的并发性能带来很大的压力。共享数据的锁状态只会持续很短的一段时间，为了这段时间去挂起线程和恢复线程并不值得。如果物理机上有一个以上的处理器，能够让两个或以上的线程并发执行，就可以让后面请求的线程“稍等一下”，但是并不放弃处理器时间，看看持有锁的线程是否很快就会释放锁。

为了让线程等待，我们只需让等待锁的线程执行一个忙循环（自旋），即所谓的自旋锁。


可使用 -XX:+UseSpining参数开启自旋锁，在JDK 1.6之后默认是开启的。自旋并不能代替阻塞，它要求两个处理器以上，并且需要占有CPU时间。如果持有线程工作时间很短，那么自旋效果会很好；反之，自旋的线程会白白消耗CPU工作时间。所以自旋等待获取锁的线程必须要有一定的限度，如过自旋超过一定次数，那么就挂起线程，按照传统的方法去处理。自旋次数默认是10次，可使用 -XX:preBlockSpin来更改。


自适应自旋意味着自旋次数不再固定。如果在同一个锁对象上，自旋等待不久之前成功获得过锁，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续相对更长的时间。另外，如果对于某个锁，当前线程自旋很少成功过，那么在以后要获取这个锁将可能省略掉自旋过程。