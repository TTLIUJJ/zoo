# 分布式知识

- CAP定理
- BASE理论
- 2PC协议
- 3PC协议
- Paxos算法
- Raft算法
- ZAB协议
- Zookeeper的运用
- 分布式系统架构




## CAP理论

一个分布式系统不可能同时满足：一致性、可用性和分区容错性。最多只能同时满足两项，注意是最多。

- 一致性：指的是数据在多个副本之间是否能够保持一致的特性。如果一个分布式节点更新数据之后，能够保证其他副本节点读取到的数据也是最新的，那么这样的系统就被认为是具有严格一致性（强一致性）。

- 可用性：指的是系统提供的服务必须一直处于可用的状态，对于用户的每次请求必须满足两点：
	
	- 有限时间响应：这个时间界限由业务决定，比如学校读书馆的图书检索和google搜索的响应时间就有所区别

	- 返回结果：响应请求的结果只能是成功或失败，不能返回一个让用户迷惑的结果

- 分区容错性：指的是分布式系统在遇到任何网络分区的故障时，仍然可以保证对外提供满足一致性和可用的服务，除非是整个网络都崩溃。比如某一个网络节点与主网络发生通信故障，但还可以向外界提供服务。

对于一个分布式系统来说，分区容错性是最基本的要求。因为分布式系统必然要求节点部署在不同的节点，而子网络与其他网络通信不可以避免的会出现网络问题。


## BASE理论

BASE是CAP中对一致性和可用性的权衡的结果，其来源于大规模网络系统分布式事件的总结，是基于CAP定理逐渐演化，核心思想：即使无法做到强一致性，但每个应用都可以根据自身的业务特点，采用恰当的方式来使系统达到最终一致性。

- 基本可用：指的是分布式系统在出现不可预知的故障之后，允许允许部分的可用性，注意并不等价于系统不可以用，举两个栗子：
	
	- 响应时间上的损失：google搜索引擎某个节点挂了，造成该地区查询时间提高1-2秒。
	
	- 功能上的损失：双11高并发购物，为了保护购物系统的稳定，部分消费者被引导到一个降级的页面。

- 软状态：指的是允许系统中的数据存在中间状态，并认为中间状态的存在并不会影响系统的整体可用性，也就是允许不同节点之间的数据副本同步过程中存在延时。举个栗子，将频繁的点赞点踩数量放在缓存，隔一段时间再刷入数据库，其他节点副本可以接受这段时间内点赞/点踩的数据差异。

- 最终一致性：指的是系统中所有数据的副本，在经过一段时间的同步之后，最终能够达到一个一致的状态，而不需要实时保证系统数据的强一致性。


## 二阶段提交协议

当一个事务需要跨越多个分布式节点的时候，为了保持事务的ACID特性，就需要引入一个称为“协调者”的组件来调度所有分布式节点，而被调度的节点称为“参与者”。协调者调度参与者的行为，并最终节决定这些参与者是否要把事务真正进行提交。

二阶段提交协议如果一切顺利，包括以下两阶段：

- 投票阶段：

	- 发送事务：协调者向参与者发送事务内容，等待参与者响应
	- 执行事务：参与者执行事务，但是不进行提交，并保存日志记录
	- 返回响应：参与者事务执行成功返回YES，反之返回NO

- 提交阶段：

	- 发送提交：协调者向所有参与者发出Commit请求
	- 提交事务：参与者Commit事务之后释放整个事务占有的资源
	- 返回结果：参与者向协调发送ACK消息
	- 结束事务：协调者在收到所有参与者的反馈ACK，提交事务

	
二阶段协议中可能中断事务的情况：

- 参与者执行事务失败返回NO，协调者发送Rollback请求

- 协调者在提交事务阶段，等待超时

优点：
 
 - 原理简单、实现方便
 
 - 属于强一致性

缺点：

 - 同步阻塞：在提交阶段，所有参与该事务操作的逻辑都处于阻塞状态。
 
 - 单点问题：协调者故障，整个流程无法运转。如果在提交阶段故障，参与者们会一直处于阻塞阶段。
 
 - 脑裂：在提交阶段，局部网络异常或者是协调者在发送部分Commit请求之后故障，会造成分布式系统数据不一致的问题。
 
 - 太过保守：任意一个参与者节点的故障或者失败都会导致整个事务的失败，并且协调者只能通过超时等待判断参与者节点故障

 
## 三阶段提交协议
 
三阶段提交协议如果一切顺利的话，包括以下三个阶段：

- CanCommit
	
	- 查询事务：协调性向参与者发送canCommit请求，询问是否可以执行事务
	- 返回响应：参与者根据自身情况，认为能够执行事务返回YES，反之返回NO 
	
- PreCommit

	- 请求预提交：协调者向参与者发送preCommit请求
	- 执行预提交：参与者执行事务操作，不进行Commit，并记录日志
	- 返回响应： 参与者若成功执行事务，返回ACK消息  

- doCommit

	- 发送提交：协调者向所有参与者者发送doCommit请求
	- 提交事务：参与者提交事务
	- 返回结果：完成提交事务返回ACK响应 
	- 结束事务：协调者收到所有参与者的反馈，提交事务

三阶段协议中可能中断事务的情况：

- 在canCommit阶段中，某一参与者返回NO，协调者发出abort请求

- 在preCommit阶段中，某一参与者没有返回ACK消息或者返回NO响应，协调者发出abort请求

- 在canCommit和preCommit阶段出现等待超时

优点：

- “非阻塞协议”：2PC协议中，只有协调者拥有超时机制，一旦协调者故障， 参与者可能阻塞于等待执行Commit/Rollback的操作；而3PC协议中，参与者也拥有等待超时机制，在doCommit阶段中，如果协调者发生故障或者网络通信出现问题导致等待超时，参与者会直接提交事务。
 
缺点：

- 无法避免脑裂的情况：在preCommit阶段，由于网络原因只有部分参与者收到doCommit。

## Paxos算法


Paxos算法主要是用于保证分布式存储中副本（或状态）的一致性。副本要保持一致，那么所有副本的更新序列就要保持一致。因此为数据的增删改查操作一般都存在多个客户端的并发操作，到底哪个客户端先做，哪个后做，这就是更新顺序。

如果不是采用分布式，可以采用简单加锁的方法，谁先申请到锁，谁就先操作。但是在分布式的条件下，存在多个副本，如果依赖申请锁+副本同步更新完毕再次释放锁，那么需要有分配锁的一个节点，但是如果锁只有一个，会出现单点问题，失去了可靠性，如果加入多个锁分配节点，问题又和前面的一样。

Paxos算法通过选举解决决定执行顺序的问题，即少数服从多数的思想，只要在2N+1个节点中，有N个以上同意了某次决定，则认为系统达到了一致，并且系统会广播所有客户端这个决定，最终达到分布式副本一致的状态。

优点：

- 客户端只需和大部分服务器通信
- 允许部分服务器故障，只需保证半数以上存活，容错性高
- 为了避免一开始客户端发送大量的通知给服务器，造成服务器集群很难快速达到半数以上与某一客户端达成一致，使用Fast Paxos进行改进

以一种游戏规则的方式来描述Paxos算法：

假设羊村村长任期已到，现在需要选举新一任的村长，组织结构为：5只候选羊（什么也不做），3只评审羊（贪污属性），10只投票羊（贿赂、墙头草属性），投票羊必须与评审羊群短信投票，3只评审羊并不相互通信，并且会在申请阶段收到贿赂。票和评审羊的决定都包括两个属性（候选羊id+申请会话时间）

首先看一下投票羊的两步操作逻辑：

- 申请会话阶段：由于每只投票羊随时都发短信给评审羊，所以评审羊一直会收到不同的投票羊的推举短信，而评审羊在任一时刻只能与一个投票羊进行沟通，评审羊以收到短信时间的为准，只与最近发送短信的投票羊进行通信。投票羊可能收到两种回复：
	
	- 投票短信滞后，驳回沟通
	- 投票短信确认，同意沟通
	
	在申请会话阶段，只有获得半数以上同意请求会话的投票羊，才有资格进行投票资格，即才能进行下一步的操作。由于评审羊只能同时与一个投票羊会话，所以不可能同时出现两只投票羊拥有投票资格。但是，这种会话是可以被其他投票羊通过再次更新短信抢占。
	
- 投票沟通阶段：选择和投票羊X会话的评审羊群（不一定是全部，半数以上即可），根据候选羊的反馈，可以分为两种情况：

	- 所有的评审羊都还未做决定，投票羊再次告诉评审羊自己的票，可能会出现两种结果：	
		- 一半的候选羊同意投票羊X，意味着整个选举结束，其他投票羊最终会接受到这一消息。
		- 没有过半，原因是评审羊可能故障无法给出回应（中风了），也可能是评审羊接收到更新的票（又有贿赂，美滋滋），驳回投票。
	
	- 至少有一个评审羊告知投票羊决定的候选羊，投票羊X会收到不同评审羊告知的决定（候选羊id+申请会话时间），并且检查是否有某一候选羊被半数同意
		- 是，那么下一任村长已决定，多说无益。
		- 否，作为一只拥有墙头草属性并与时俱进的投票羊，会检查所有决定的申请时间，并且支持拥有最新时间的候选羊
	
看一下评审羊的操作逻辑：

- 申请阶段：只会选择与最近发短信给自己投票羊进行会话
- 沟通阶段：1.没有决定其他候选羊人选 2. 已决定候选羊，洗脑投票羊

在沟通会话阶段，投票羊B会再次把自己票告诉给评审羊，评审羊确认该申请会话时间之内，没有其他投票羊的申请会话请求（没有接受到新的贿赂），那么就同意投票羊的投票。值得注意的是，贪婪的评审羊即使在很早之前做过决定，也会抛弃它。相反，如果投票羊D紧随其后，在评审羊发送同意之前，申请一次新的会话，那么投票羊B的请求就会被驳回（贿赂打水漂）。

## Raft算法

在一个由Raft协议组织的集群中有三类角色：

- Leader（领袖）
- Follower（群众）
- Candidate（候选人）

在没有Leader之前，所有集群中参与者都是Follwer，那么在系统开启选举之前，所有的Follower都能够参与竞选，成为Candidate，投票选出Leader之后，就开始了该Leader的任期（term），其余Candidate变为Follower。 

### Leader选举过程

一个最小的Raft选举需要三个参与者，这样才能投出多数票。初始状态下ABC都是Follower，然后发起选举时有三种可能的情形发生。下图的前两种都能选出Leader，第三种则表示本轮投票无效（没有人获得多数票），之后每个投票人随机休眠一段时间（Election Timeout）后，重新发起投票直到一方获得多数票。这里关键是随机时间的timeout，最先从timeout恢复起投票的一方向还在休眠的其他方发起投票请求，这时它们只能投给对方了。

![](http://owj98yrme.bkt.clouddn.com/815275-20160301175349689-522400583.png)

选出Leader之后，Leader通过定期向所有Follwer发送心跳信息维持统治。若Follower一段时间未收到Leader的心跳则认为Leader可能已经挂了，再次发起选主过程。

### Leader节点对一致性的影响

Raft协议强依赖Leader节点的可用性来保证集群数据的一致性。数据的流只能从Leader节点向Follower节点转移。

- 当客户端向集群Leader节点提交数据之后，Leader节点接收到的数据处于未提交状态，然后向所有的Follower节点复制数据并且等待接收响应

- 确保集群中有超过半数的节点已经接收到数据后，再向客户端确认数据已经接收。

- 一旦Leader收到客户端的ACK响应之后，表明进入已提交阶段，Leader节点再向Follower节点发送提交数据状态。

![](http://owj98yrme.bkt.clouddn.com/815275-20160301175358173-526445555.png)

在这个过程中，Leader节点可能在任意阶段挂掉，看下Raft协议如何针对不用的阶段保障数据一致性的。


#### 1. 数据到达Leader节点前

这个阶段Leader挂掉不影响一致性。


![](http://owj98yrme.bkt.clouddn.com/815275-20160301175405705-1452838896.png)

#### 2. 数据到达Leader节点，但未复制到Follower节点

这个阶段Leader挂掉，数据属于未提交状态，客户端不会收到ACK会认为超时失败。由于Follower节点没有该数据，重新选举Leader之后，客户端重试提交可成功。旧Leader节点恢复后作为Follower加入集群，同步新任Leader的数据，强制保持和Leader的数据一致性。

![](http://owj98yrme.bkt.clouddn.com/815275-20160301175412580-649716029.png)

#### 3. 数据到达Leader节点，成功复制到所有Follower节点，但未响应Leader



## ZAB协议

Zookeeper主要是依据ZAB协议实现分布式系统数据一致性。它不像是Paxos算法是一种通用的分布式一致性算法，它一种特别为Zookeeper设计的崩溃可恢复的原子消息广播协议。


#### ZAB协议主要实现了：

- 使用一个单一的主进程来接收并处理客户端的所有事务请求，采用ZAB协议，将服务器数据的状态变更以事务Proposal的形式广播到所有副本的进程上。

- 保证一个全局变更的序列可以有序的应用

 ```
 	- /root 
			
			- /garden
 	       			
 	       			- /folwer
 	       						- /rose-0000001
 	       						- /rose-0000002
 	       						- /lily
 	       						- /rose-0000003
 	       					
 	       			- /grass
 	        
 	       - /zoo

 	
 ```


- 当主进程出现异常的时候，整个系统依旧可以正常工作。


#### ZAB协议的核心：定义了请求事务的处理方式

所有事务的请求必须由一个全局唯一的服务器（Leader）来协调处理，负责将一个客户端的事务请求转换成一个事务proposal（提议），并将该提议分发给集群中剩余的服务器（Follower），之后Leader等待所有Follwer服务器的反馈，一旦超过半数的是Follwer进行了正确反馈，那么Leader服务器会再次向所有的Follwer发送Commit请求。

与二阶段提交协议不同的是，二阶段提交协议中的提交阶段中，需要等待所有的参与者返回"YES"才会提交事务，只要一个参与返回"NO"或等待超时都要回滚事务。


#### ZAB协议包括两种基本的工作模式：消息广播和崩溃恢复


- 消息广播
	
	- 在消息广播过程中，Leader服务器会为每个事务请求生成对应的Proposal进行广播，并且在广播事务Proposal之前，Leader服务器为Proposal分配一个去全局单调递增的唯一事务ID（即ZXID，64位，高32为Leader周期，低32位为处理事务请求的计数器）
	
	- Leader服务器会每个Follwer服务器都分配一个单独的队列，然后将需要广播的事务Proposal依次放入到FIFO队列中，每一个Follower在收到Proposal之后，将事务以日志形式写入成功之后返回ACK响应。当Leader服务器收到半数以上Follower的ACK之后，就会广播一个Commit给所有的Follower服务器，同时Leader提交本事务

- 崩溃恢复（Leader服务器与半数Follower失去联系）：Leader选举算法需要让自身服务器和其他Follower服务器迅速感知到。ZAB协议规定了一个事务Proposal如果在一台机器上处理成功，那么无论如何应该在所有机器上被处理成功。
	
	-  ZAB协议需要确保已经在Leader服务器上提交的事务最终都会被所有Follower服务器提交
	
	-  ZAB协议需要确保丢弃那些只在Leader服务器被提出的事务，而不是来自客户端的事务，比如Leader服务器在提出一个事务Prosal之后就崩溃了（其他Follower没收到Proposal），当它恢复重新加入集群中，ZAB协议需要确保丢弃该事务。
	
- 数据同步

	- 确保所有服务器提交已被Leader提交的事务：Leader服务器为每个Follower服务器提供一个FIFO队列，并将已被服务器提交，Follower未同步的事务发送Proposa+commmit消息，表示该事务你尚未被完成，请自觉提交该事务。等到Follwer服务器与Leader服务器完成同步之后，Leader服务器才会将该服务器加入可用的Follower服务器列表。
	
	- 确保需要被丢弃的Proposal：针对每个客户端的事务请求，低32位加1，每当选取一个新的Leader，ZXID的高32位加1，就会从这个Leader服务器上取出本地日志中最大事务Proposal的ZXID，并从解析出高32位epoch值，进行加1操作，然后将低32位置0，拼成新的ZXID

	 - 基于这样的策略，当包含了上一个Leader周期中尚未提交的Proposal的服务器加入到集群中，发现已存在新Leader，旧Leader变为Follower角色，一旦新Leader发现旧Leader（新Follwer）有上个周期事务的Proposal请求，要求旧Leader回退到集群中半数机器提交的最新事务Proposal的状态
	
	
- ZAB协议Leader选举 

	- ...太复杂了没搞懂
	
	
	
## Zookeeper的应用




## 分布式系统架构


	









